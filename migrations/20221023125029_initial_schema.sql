create table "public"."comments" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "post_id" bigint,
    "body" text,
    "creator_uuid" uuid
);


alter table "public"."comments" enable row level security;

create table "public"."likes" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "post_id" bigint,
    "creator_uuid" uuid
);


alter table "public"."likes" enable row level security;

create table "public"."posts" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "image_url" text,
    "description" text,
    "creator_uuid" uuid
);


alter table "public"."posts" enable row level security;

create table "public"."users" (
    "created_at" timestamp with time zone default now(),
    "first_name" text,
    "last_name" text,
    "image_url" text,
    "uuid" uuid not null
);


alter table "public"."users" enable row level security;

CREATE UNIQUE INDEX comments_pkey ON public.comments USING btree (id);

CREATE UNIQUE INDEX likes_pkey ON public.likes USING btree (id);

CREATE UNIQUE INDEX posts_pkey ON public.posts USING btree (id);

CREATE UNIQUE INDEX users_pkey ON public.users USING btree (uuid);

alter table "public"."comments" add constraint "comments_pkey" PRIMARY KEY using index "comments_pkey";

alter table "public"."likes" add constraint "likes_pkey" PRIMARY KEY using index "likes_pkey";

alter table "public"."posts" add constraint "posts_pkey" PRIMARY KEY using index "posts_pkey";

alter table "public"."users" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";

alter table "public"."comments" add constraint "comments_creator_uuid_fkey" FOREIGN KEY (creator_uuid) REFERENCES users(uuid) not valid;

alter table "public"."comments" validate constraint "comments_creator_uuid_fkey";

alter table "public"."comments" add constraint "comments_post_id_fkey" FOREIGN KEY (post_id) REFERENCES posts(id) not valid;

alter table "public"."comments" validate constraint "comments_post_id_fkey";

alter table "public"."likes" add constraint "likes_creator_uuid_fkey" FOREIGN KEY (creator_uuid) REFERENCES users(uuid) not valid;

alter table "public"."likes" validate constraint "likes_creator_uuid_fkey";

alter table "public"."likes" add constraint "likes_post_id_fkey" FOREIGN KEY (post_id) REFERENCES posts(id) not valid;

alter table "public"."likes" validate constraint "likes_post_id_fkey";

alter table "public"."posts" add constraint "posts_creator_uuid_fkey" FOREIGN KEY (creator_uuid) REFERENCES users(uuid) not valid;

alter table "public"."posts" validate constraint "posts_creator_uuid_fkey";

alter table "public"."users" add constraint "users_uuid_fkey" FOREIGN KEY (uuid) REFERENCES auth.users(id) not valid;

alter table "public"."users" validate constraint "users_uuid_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  insert into public.users (uuid)
  values (new.id);
  return new;
end;
$function$
;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

create policy "Enable delete for users based on creator_uuid"
on "public"."comments"
as permissive
for delete
to public
using ((auth.uid() = creator_uuid));


create policy "Enable insert for authenticated users only"
on "public"."comments"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable update for users based on uuid"
on "public"."comments"
as permissive
for update
to public
using ((auth.uid() = creator_uuid))
with check ((auth.uid() = creator_uuid));


create policy "Enable delete for users based on creator_uuid"
on "public"."posts"
as permissive
for delete
to public
using ((auth.uid() = creator_uuid));


create policy "Enable insert for authenticated users only"
on "public"."posts"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for own posts"
on "public"."posts"
as permissive
for select
to authenticated
using ((auth.uid() = creator_uuid));


create policy "Enable update for users based on uuid"
on "public"."posts"
as permissive
for update
to public
using ((auth.uid() = creator_uuid))
with check ((auth.uid() = creator_uuid));


create policy "Enable insert for authenticated users only"
on "public"."users"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable update for users based on uuid"
on "public"."users"
as permissive
for update
to authenticated
using ((auth.uid() = uuid))
with check ((auth.uid() = uuid));



